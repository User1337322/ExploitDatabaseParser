using ExploitDatabaseParser.Entity.Models;
using HtmlAgilityPack;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using System.Net;
using System.Text.RegularExpressions;

namespace ExploitDatabaseParser
{
    public class ExploitParser
    {
        private HtmlWeb web { get; set; }
        public ExploitParser() {
            web = new HtmlWeb();
        }
        public async Task<ExploitModel> GetExploitInformation(string reference)
        {
      
            ExploitModel exploit = new ExploitModel();
        
            string correctUrlString = "https://" + reference;

            exploit.ExploitUrl = correctUrlString;
            try
            {
                HtmlDocument document = await web.LoadFromWebAsync(correctUrlString);

                var h6Nodes = document.DocumentNode.SelectNodes("//div[@class='col-6 text-center']/h6[@class='stats-title']");

                //add title to the entity 
                HtmlNode h1Node = document.DocumentNode.SelectSingleNode("//h1[@class='card-title text-secondary text-center']");
                string title = h1Node.InnerText.Trim();

                exploit.Title = title;


                if (h6Nodes != null && h6Nodes.Count >= 2)
                {
                    //edb-id
                    string id = h6Nodes[0].InnerText.Trim();
                    exploit.EDB_Id = id;
                    //cve-stringid
                    string cveStringId = h6Nodes[1].InnerText.Trim();
                    string normalizedCVE = Regex.Replace(cveStringId, @"\s+", " ").Trim();
                    List<RelatedCve> cves = new List<RelatedCve>();
                    foreach(var record in normalizedCVE.Split(' '))
                    {
                        cves.Add(new RelatedCve() { 
                            StringId=record
                        });
                    }
                    exploit.RelatedCves = cves;
                    exploit.CVE = normalizedCVE;
                    //is verified 
                    HtmlNode iNode = document.DocumentNode.SelectSingleNode("//i[@class='mdi mdi-24px mdi-check']");
                    bool isVerified = (iNode != null && iNode.Attributes["style"]?.Value.Contains("color: #96b365") == true);
                    exploit.IsVerified = isVerified;


                    //author 
                    string author = h6Nodes[2].InnerText.Trim();
                    exploit.Author = author;

                    string typeString = h6Nodes[3].InnerText.Trim();
                    Entity.Models.Type type = GetEnumValue(typeString, Entity.Models.Type.None);
                    exploit.Type = type;
                    exploit.TypeString = typeString;

                    string platformString = h6Nodes[4].InnerText.Trim();
                    Entity.Models.Platform platform = GetEnumValue(platformString, Platform.None);
                    exploit.Platform = platform;
                    exploit.PlatformName = platformString;

                    string date = h6Nodes[5].InnerText.Trim();
                    exploit.Date = DateTime.Parse(date);
                    ///download/51747

                    //Vulnarable application 
                    HtmlNodeCollection aNode = document.DocumentNode.SelectNodes("//div[@class='stats h5 text-center']/a");

                    // Getting calue for downloading application
                    string hrefValue = aNode[0].GetAttributeValue("href", "");
                    byte[] rawCodeFile;
                    //Getting not vulnarable application but raw code in file
                    if (hrefValue != null && !string.IsNullOrEmpty(hrefValue))
                    {
                        string dowloadRawCodeUrl = "https://www.exploit-db.com" + hrefValue;
                        rawCodeFile = await DowloadWebFile(dowloadRawCodeUrl);
                        exploit.RawCodeFile = rawCodeFile;
                    }
                    byte[] vulAppData;
                    if(aNode.Count == 3)
                    {
                        string applicationReference = aNode[2].GetAttributeValue("href", "");
                        string removeSubstring = "/apps/";

                        exploit.VulnerableApplicationName = applicationReference.Remove(0, 6);

                        if (applicationReference != null && !string.IsNullOrEmpty(applicationReference))
                        {
                            string dowloadApplicationUrl = "https://www.exploit-db.com" + applicationReference;
                            exploit.HasApp = true;
                            await Console.Out.WriteLineAsync(dowloadApplicationUrl);
                            vulAppData = await DowloadWebFile(dowloadApplicationUrl);
                            exploit.VulnarableApplicationData = vulAppData;
                        }
                    }
                    var codeToolbarNode = document.DocumentNode.SelectNodes("//div[@class='card-body']");

                    if (codeToolbarNode != null && codeToolbarNode.Count > 1)
                    {
                        string codeTextString = codeToolbarNode[1].InnerText.Trim();
                        exploit.Code = codeTextString;
                    }
                    //Tag
                    HtmlNode tagNode = document.DocumentNode.SelectSingleNode("//a[@href and contains(@href, '/?tag=')]");
                    string tagName = "";
                    if (tagNode != null)
                    {
                        tagName = tagNode.InnerText.Trim();

                        Tag exploitTag = GetEnumValue<Entity.Models.Tag>(tagName, Tag.None);
                        exploit.Tag = exploitTag;
                        exploit.TagString = tagName;
                    }

                    //getting raw code string from url 
                    string rawCodeUrlString = correctUrlString.Replace("exploits", "raw");


                    //Getting text from element
                    string codeText = GetRawCodeHtmlPage(rawCodeUrlString);
                    exploit.Code = codeText;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred: {ex.Message}");
            }
            return exploit;
        }
        private T GetEnumValue<T>(string enumString, T defaultValue) where T : struct, Enum
        {
            if (Enum.TryParse<T>(enumString, true, out T result))
            {
                return result;
            }
            return defaultValue;
        }
        //For dowloading raw code and application 
        private async Task<byte[]> DowloadWebFile(string fileUrl)
        {
            using (var client = new WebClient())
            {
                client.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36");
                try
                {
                    return await client.DownloadDataTaskAsync(new Uri(fileUrl));
                }
                catch (WebException ex)
                {
                    Console.WriteLine($"Error while downloading vulnarable application {ex.Message}");
                    return null;
                }
            }
        }
        private string GetRawCodeHtmlPage(string rawCodeUrlString)
        {
            using (HttpClient client = new HttpClient())
            {
                try
                {
                    client.DefaultRequestHeaders.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36");
                    // Выполняем HTTP-запрос и получаем HTML-контент
                    return client.GetStringAsync(rawCodeUrlString).Result;
                   
                }
                catch (HttpRequestException ex)
                {
                    Console.WriteLine($"Error while page downloading: {ex.Message}");
                    throw new Exception(ex.Message);
                }
            }
        }
        public async Task<IEnumerable<string>> GetReferencesFromFileAsync(string filePath)
        {
            var exploitReferences = new List<string>();
            try
            {
                using (StreamReader reader = new StreamReader(filePath))
                {
                    string line = string.Empty;
                    while ((line = await reader.ReadLineAsync()) != null)
                    {
                        exploitReferences.Add(line);
                    }
                }
            }
            catch (IOException ex)
            {
                Console.WriteLine($"Error reading file: {ex.Message}");
            }
            return exploitReferences;
        }
  

    }
}
